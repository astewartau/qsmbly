//! Projection onto Dipole Fields (PDF) background field removal
//!
//! Projects the field onto dipole fields generated by sources outside
//! the brain mask, separating background and local fields.
//!
//! Reference:
//! Liu T, Khalidov I, de Rochefort L, Spincemaille P, Liu J, Tsiouris AJ,
//! Wang Y. A novel background field removal method for MRI using projection
//! onto dipole fields. NMR in Biomedicine. 2011 Nov;24(9):1129-36.

use num_complex::Complex64;
use crate::fft::{fft3d, ifft3d};
use crate::kernels::dipole::dipole_kernel;

/// PDF background field removal
///
/// # Arguments
/// * `field` - Total field (nx * ny * nz)
/// * `mask` - Binary mask (nx * ny * nz), 1 = brain, 0 = background
/// * `nx`, `ny`, `nz` - Array dimensions
/// * `vsx`, `vsy`, `vsz` - Voxel sizes in mm
/// * `bdir` - B0 field direction
/// * `tol` - Convergence tolerance for LSMR
/// * `max_iter` - Maximum iterations for LSMR
///
/// # Returns
/// Local field with background removed
pub fn pdf(
    field: &[f64],
    mask: &[u8],
    nx: usize, ny: usize, nz: usize,
    vsx: f64, vsy: f64, vsz: f64,
    bdir: (f64, f64, f64),
    tol: f64,
    max_iter: usize,
) -> Vec<f64> {
    let n_total = nx * ny * nz;

    // Generate dipole kernel
    let d_kernel = dipole_kernel(nx, ny, nz, vsx, vsy, vsz, bdir);

    // Create background mask (complement of brain mask)
    let bg_mask: Vec<f64> = mask.iter()
        .map(|&m| if m == 0 { 1.0 } else { 0.0 })
        .collect();

    // Brain mask as f64
    let brain_mask: Vec<f64> = mask.iter()
        .map(|&m| if m != 0 { 1.0 } else { 0.0 })
        .collect();

    // RHS: b = W * f where W is brain mask weights
    let b: Vec<f64> = field.iter()
        .zip(brain_mask.iter())
        .map(|(&f, &w)| f * w)
        .collect();

    // Solve A*x = b using LSMR where:
    // A = W * D * M_bg (apply background mask, convolve with D, apply weights)
    // A^T = M_bg * D^T * W

    // Initialize solution
    let mut x = vec![0.0; n_total];

    // LSMR iteration
    // We solve: W * D * M_bg * x = W * f
    // This finds background sources x such that their dipole field
    // matches the field in the brain region

    let mut u = b.clone();  // u = b - A*x, initially b since x=0
    let mut beta = vec_norm(&u);

    if beta < 1e-20 {
        // Field is zero in brain, return zeros
        return vec![0.0; n_total];
    }

    // Normalize u
    for i in 0..n_total {
        u[i] /= beta;
    }

    // v = A^T * u
    let mut v = apply_at(&u, &brain_mask, &d_kernel, &bg_mask, nx, ny, nz);
    let mut alpha = vec_norm(&v);

    if alpha < 1e-20 {
        return vec![0.0; n_total];
    }

    // Normalize v
    for i in 0..n_total {
        v[i] /= alpha;
    }

    // LSMR variables
    let mut w = v.clone();
    let mut phi_bar = beta;
    let mut rho_bar = alpha;

    for _iter in 0..max_iter {
        // Bidiagonalization
        // u = A*v - alpha*u
        let av = apply_a(&v, &bg_mask, &d_kernel, &brain_mask, nx, ny, nz);
        for i in 0..n_total {
            u[i] = av[i] - alpha * u[i];
        }
        beta = vec_norm(&u);

        if beta < 1e-20 {
            break;
        }

        for i in 0..n_total {
            u[i] /= beta;
        }

        // v = A^T*u - beta*v
        let atu = apply_at(&u, &brain_mask, &d_kernel, &bg_mask, nx, ny, nz);
        for i in 0..n_total {
            v[i] = atu[i] - beta * v[i];
        }
        alpha = vec_norm(&v);

        if alpha < 1e-20 {
            break;
        }

        for i in 0..n_total {
            v[i] /= alpha;
        }

        // Construct and apply rotation
        let rho = (rho_bar * rho_bar + beta * beta).sqrt();
        let c = rho_bar / rho;
        let s = beta / rho;
        let theta = s * alpha;
        rho_bar = -c * alpha;
        let phi = c * phi_bar;
        phi_bar = s * phi_bar;

        // Update x and w
        let phi_rho = phi / rho;
        let theta_rho = theta / rho;

        for i in 0..n_total {
            x[i] += phi_rho * w[i];
            w[i] = v[i] - theta_rho * w[i];
        }

        // Check convergence
        let norm_r = phi_bar.abs();
        let norm_x = vec_norm(&x);
        if norm_r < tol * (norm_x + 1e-20) {
            break;
        }
    }

    // Compute background field: b_field = D * (M_bg * x)
    let mut bg_source: Vec<Complex64> = x.iter()
        .zip(bg_mask.iter())
        .map(|(&xi, &m)| Complex64::new(xi * m, 0.0))
        .collect();

    fft3d(&mut bg_source, nx, ny, nz);

    // Apply dipole kernel
    for i in 0..n_total {
        bg_source[i] *= d_kernel[i];
    }

    ifft3d(&mut bg_source, nx, ny, nz);

    // Local field = total field - background field, masked
    let mut local_field = vec![0.0; n_total];
    for i in 0..n_total {
        if mask[i] != 0 {
            local_field[i] = field[i] - bg_source[i].re;
        }
    }

    local_field
}

/// Apply A = W * D * M_bg
fn apply_a(
    x: &[f64],
    bg_mask: &[f64],
    d_kernel: &[f64],
    brain_mask: &[f64],
    nx: usize, ny: usize, nz: usize,
) -> Vec<f64> {
    let n_total = nx * ny * nz;

    // Apply background mask
    let mut temp: Vec<Complex64> = x.iter()
        .zip(bg_mask.iter())
        .map(|(&xi, &m)| Complex64::new(xi * m, 0.0))
        .collect();

    // FFT
    fft3d(&mut temp, nx, ny, nz);

    // Apply dipole kernel
    for i in 0..n_total {
        temp[i] *= d_kernel[i];
    }

    // IFFT
    ifft3d(&mut temp, nx, ny, nz);

    // Apply brain mask weights
    temp.iter()
        .zip(brain_mask.iter())
        .map(|(t, &w)| t.re * w)
        .collect()
}

/// Apply A^T = M_bg * D * W
fn apply_at(
    u: &[f64],
    brain_mask: &[f64],
    d_kernel: &[f64],
    bg_mask: &[f64],
    nx: usize, ny: usize, nz: usize,
) -> Vec<f64> {
    let n_total = nx * ny * nz;

    // Apply brain mask weights
    let mut temp: Vec<Complex64> = u.iter()
        .zip(brain_mask.iter())
        .map(|(&ui, &w)| Complex64::new(ui * w, 0.0))
        .collect();

    // FFT
    fft3d(&mut temp, nx, ny, nz);

    // Apply dipole kernel (D is real and symmetric)
    for i in 0..n_total {
        temp[i] *= d_kernel[i];
    }

    // IFFT
    ifft3d(&mut temp, nx, ny, nz);

    // Apply background mask
    temp.iter()
        .zip(bg_mask.iter())
        .map(|(t, &m)| t.re * m)
        .collect()
}

/// Vector 2-norm
fn vec_norm(v: &[f64]) -> f64 {
    v.iter().map(|&x| x * x).sum::<f64>().sqrt()
}

/// PDF with progress callback
///
/// Same as `pdf` but calls `progress_callback(iteration, max_iter)` each iteration.
pub fn pdf_with_progress<F>(
    field: &[f64],
    mask: &[u8],
    nx: usize, ny: usize, nz: usize,
    vsx: f64, vsy: f64, vsz: f64,
    bdir: (f64, f64, f64),
    tol: f64,
    max_iter: usize,
    mut progress_callback: F,
) -> Vec<f64>
where
    F: FnMut(usize, usize),
{
    let n_total = nx * ny * nz;

    // Generate dipole kernel
    let d_kernel = dipole_kernel(nx, ny, nz, vsx, vsy, vsz, bdir);

    // Create background mask (complement of brain mask)
    let bg_mask: Vec<f64> = mask.iter()
        .map(|&m| if m == 0 { 1.0 } else { 0.0 })
        .collect();

    // Brain mask as f64
    let brain_mask: Vec<f64> = mask.iter()
        .map(|&m| if m != 0 { 1.0 } else { 0.0 })
        .collect();

    // RHS: b = W * f where W is brain mask weights
    let b: Vec<f64> = field.iter()
        .zip(brain_mask.iter())
        .map(|(&f, &w)| f * w)
        .collect();

    // Initialize solution
    let mut x = vec![0.0; n_total];

    let mut u = b.clone();
    let mut beta = vec_norm(&u);

    if beta < 1e-20 {
        return vec![0.0; n_total];
    }

    for i in 0..n_total {
        u[i] /= beta;
    }

    let mut v = apply_at(&u, &brain_mask, &d_kernel, &bg_mask, nx, ny, nz);
    let mut alpha = vec_norm(&v);

    if alpha < 1e-20 {
        return vec![0.0; n_total];
    }

    for i in 0..n_total {
        v[i] /= alpha;
    }

    let mut w = v.clone();
    let mut phi_bar = beta;
    let mut rho_bar = alpha;

    for iter in 0..max_iter {
        // Report progress
        progress_callback(iter + 1, max_iter);

        let av = apply_a(&v, &bg_mask, &d_kernel, &brain_mask, nx, ny, nz);
        for i in 0..n_total {
            u[i] = av[i] - alpha * u[i];
        }
        beta = vec_norm(&u);

        if beta < 1e-20 {
            progress_callback(iter + 1, iter + 1);
            break;
        }

        for i in 0..n_total {
            u[i] /= beta;
        }

        let atu = apply_at(&u, &brain_mask, &d_kernel, &bg_mask, nx, ny, nz);
        for i in 0..n_total {
            v[i] = atu[i] - beta * v[i];
        }
        alpha = vec_norm(&v);

        if alpha < 1e-20 {
            progress_callback(iter + 1, iter + 1);
            break;
        }

        for i in 0..n_total {
            v[i] /= alpha;
        }

        let rho = (rho_bar * rho_bar + beta * beta).sqrt();
        let c = rho_bar / rho;
        let s = beta / rho;
        let theta = s * alpha;
        rho_bar = -c * alpha;
        let phi = c * phi_bar;
        phi_bar = s * phi_bar;

        let phi_rho = phi / rho;
        let theta_rho = theta / rho;

        for i in 0..n_total {
            x[i] += phi_rho * w[i];
            w[i] = v[i] - theta_rho * w[i];
        }

        let norm_r = phi_bar.abs();
        let norm_x = vec_norm(&x);
        if norm_r < tol * (norm_x + 1e-20) {
            progress_callback(iter + 1, iter + 1);
            break;
        }
    }

    // Compute background field: b_field = D * (M_bg * x)
    let mut bg_source: Vec<Complex64> = x.iter()
        .zip(bg_mask.iter())
        .map(|(&xi, &m)| Complex64::new(xi * m, 0.0))
        .collect();

    fft3d(&mut bg_source, nx, ny, nz);

    for i in 0..n_total {
        bg_source[i] *= d_kernel[i];
    }

    ifft3d(&mut bg_source, nx, ny, nz);

    // Local field = total field - background field, masked
    let mut local_field = vec![0.0; n_total];
    for i in 0..n_total {
        if mask[i] != 0 {
            local_field[i] = field[i] - bg_source[i].re;
        }
    }

    local_field
}

/// PDF with default parameters
pub fn pdf_default(
    field: &[f64],
    mask: &[u8],
    nx: usize, ny: usize, nz: usize,
    vsx: f64, vsy: f64, vsz: f64,
) -> Vec<f64> {
    pdf(
        field, mask, nx, ny, nz, vsx, vsy, vsz,
        (0.0, 0.0, 1.0),  // bdir
        1e-5,              // tol
        100                // max_iter
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pdf_zero_field() {
        let n = 8;
        let field = vec![0.0; n * n * n];
        let mask = vec![1u8; n * n * n];

        let local = pdf(
            &field, &mask, n, n, n, 1.0, 1.0, 1.0,
            (0.0, 0.0, 1.0), 1e-5, 10
        );

        for &val in local.iter() {
            assert!(val.abs() < 1e-10, "Zero field should give zero local field");
        }
    }

    #[test]
    fn test_pdf_finite() {
        let n = 8;
        let field: Vec<f64> = (0..n*n*n).map(|i| (i as f64) * 0.001).collect();

        // Create a spherical mask in the center
        let mut mask = vec![0u8; n * n * n];
        let center = n / 2;
        let radius = n / 4;

        for i in 0..n {
            for j in 0..n {
                for k in 0..n {
                    let di = (i as i32) - (center as i32);
                    let dj = (j as i32) - (center as i32);
                    let dk = (k as i32) - (center as i32);
                    if di*di + dj*dj + dk*dk <= (radius * radius) as i32 {
                        mask[i * n * n + j * n + k] = 1;
                    }
                }
            }
        }

        let local = pdf(
            &field, &mask, n, n, n, 1.0, 1.0, 1.0,
            (0.0, 0.0, 1.0), 1e-5, 20
        );

        for (i, &val) in local.iter().enumerate() {
            assert!(val.is_finite(), "Local field should be finite at index {}", i);
        }
    }

    #[test]
    fn test_pdf_mask() {
        let n = 8;
        let field: Vec<f64> = (0..n*n*n).map(|i| (i as f64) * 0.001).collect();
        let mut mask = vec![1u8; n * n * n];
        mask[0] = 0;
        mask[10] = 0;

        let local = pdf(
            &field, &mask, n, n, n, 1.0, 1.0, 1.0,
            (0.0, 0.0, 1.0), 1e-5, 10
        );

        assert_eq!(local[0], 0.0, "Masked voxel should be zero");
        assert_eq!(local[10], 0.0, "Masked voxel should be zero");
    }
}
